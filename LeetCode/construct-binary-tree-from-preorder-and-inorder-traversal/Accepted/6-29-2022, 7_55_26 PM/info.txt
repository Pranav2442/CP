{"id":734300953,"lang":"cpp","time":"1 week, 2 days","timestamp":1656512726,"status_display":"Accepted","runtime":"21 ms","url":"/submissions/detail/734300953/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"26.4 MB","code":"class Solution {\npublic:\n     \n    unordered_map<int,int> in;\n    TreeNode* construct(vector<int>& preorder, vector<int>& inorder,int low,int high,int& pre)\n    {\n        if(low>high)\n        {\n            --pre;\n            return nullptr;\n        }\n         TreeNode*temp = new TreeNode();\n\t\t\n        temp -> val = preorder[pre];\n\t\t\n        int index = in[preorder[pre]];\n        temp ->left = construct(preorder,inorder,low,index-1,++pre);\n        temp ->right = construct(preorder,inorder,index+1,high,++pre);\n        return temp;\n    }\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        for(int i = 0; i<inorder.size();i++)\n        {\n            in[inorder[i]] = i;\n        }\n\t\n        int pre = 0;\n        return construct(preorder,inorder,0,inorder.size()-1,pre);\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}