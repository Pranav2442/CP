{"id":737283945,"lang":"cpp","time":"2 days, 8 hours","timestamp":1656837759,"status_display":"Accepted","runtime":"107 ms","url":"/submissions/detail/737283945/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"221.9 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n     int index=0;\n   map<int,int> m;\n   TreeNode* solve(vector<int>pr,vector<int>in,int start,int end)\n   {\n     if(start>end || index>in.size() ) return NULL;\n     \n     int element=pr[index++];\n     TreeNode* root=new TreeNode(element); // adding element in ans tree\n     int posn=m[element];\n     \n     // recursive call for left and right\n     root->left= solve(pr,in,start,posn-1);  // call for left part of the posn in inorder vector\n     root->right=solve(pr,in,posn+1,end);   // call for right part of the posn in inorder vecor\n     return root;\n   }\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        \n        \n        for(int i=0;i<inorder.size();i++){\n            m[inorder[i]]=i;\n        }\n        \n        return solve(preorder,inorder,0,inorder.size()-1);\n        \n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}