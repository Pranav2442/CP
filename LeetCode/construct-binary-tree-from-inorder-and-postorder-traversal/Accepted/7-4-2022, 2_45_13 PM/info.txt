{"id":738106979,"lang":"cpp","time":"1 day, 7 hours","timestamp":1656926113,"status_display":"Accepted","runtime":"19 ms","url":"/submissions/detail/738106979/","is_pending":"Not Pending","title":"Construct Binary Tree from Inorder and Postorder Traversal","memory":"26.4 MB","code":"/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int index;\n    map<int,int> m;\n   TreeNode* solve(vector<int>& po,int start,int end)\n   {\n     if(start>end) return NULL;\n     \n     int element=po[index];\n     TreeNode* root=new TreeNode(element);\n     index--;\n     int posn=m[element];\n   \n     root->right=solve(po,posn+1,end); \n     root->left= solve(po,start,posn-1);  \n     return root;\n   }\n   TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {\n        index=postorder.size()-1;\n      int n=inorder.size();\n     \n      for(int i=0;i<n;i++)\n      {\n        m[inorder[i]]=i;\n      }\n     return solve(postorder,0,n-1);\n      \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-inorder-and-postorder-traversal"}